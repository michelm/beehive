#! /usr/bin/env python
# -*- encoding: utf-8 -*-

import os
import datetime
from waflib import Build, Logs, Node, Context
from waflib import Task

def export(bld):
	bld.commands = []
	bld.targets = []

	old_exec = Task.TaskBase.exec_command
	def exec_command(self, *k, **kw):
		ret = old_exec(self, *k, **kw)
		try:
			cmd = k[0]
		except IndexError:
			cmd = ''
		finally:
			self.command_executed = cmd
		try:
			cwd = kw['cwd']
		except KeyError:
			cwd = self.generator.bld.cwd
		finally:
			self.path = cwd
		return ret
	Task.TaskBase.exec_command = exec_command

	def compile_task(self):
		top = str(self.generator.bld.bldnode)
		lst = []
		for x in self.outputs:
			lst.append("%s/%s" % (top, x.relpath()))
		bld.targets.extend(lst)

		try:
			if isinstance(self.command_executed, list):
				t = str(self.generator.bld.path.abspath())
				cmd = []
				for c in self.command_executed:
					if c.startswith('../'):
						c = c.lstrip('../')
					if c.endswith('.o'):
						c = "%s/%s" % (top, c)
					if c.startswith("-I%s" % t):
						c = "-I%s" % c[len(t)+3:]
					cmd.append(c)
				self.command_executed = ' \\\n\t'.join(cmd)

		except Exception as e:
			print(e)
		else:
			target = str(lst.pop(0))
			bld.commands.append('%s:' % target)
			bld.commands.append('\tmkdir -p %s' % os.path.dirname(target))
			bld.commands.append('\t%s' % self.command_executed)

	def link_task(self):
		top = str(self.generator.bld.bldnode)
		lst = []
		for x in self.outputs:
			lst.append("%s/%s" % (top, x.relpath()))
		bld.targets.extend(lst)

		for x in self.inputs + self.dep_nodes + self.generator.bld.node_deps.get(self.uid(), []):
			lst.append("%s/%s" % (top, x.relpath()))

		try:
			if isinstance(self.command_executed, list):
				t = str(self.generator.bld.path.abspath())
				cmd = []
				for c in self.command_executed:
					if c.startswith('-L'):
						c = "-L%s/%s" % (top, c[2:])
					if c.startswith('../'):
						c = c.lstrip('../')
					if c.endswith('.a') or c.endswith('.o'):
						c = "%s/%s" % (top, c)
					if c.startswith(t):
						c = c[len(t)+1:]
					cmd.append(c)
				self.command_executed = ' \\\n\t'.join(cmd)

		except Exception as e:
			print(e)
		else:
			bld.commands.append('%s: \\' % os.path.basename(str(lst.pop(0))))
			bld.commands.append('\t%s' % ' \\\n\t'.join([str(l) for l in lst]))
			bld.commands.append('\t%s' % self.command_executed)

	old_process = Task.TaskBase.process
	def process(self):
		old_process(self)
		if self.__class__.__name__ in ['c','cxx']:
			compile_task(self)
		elif self.__class__.__name__ in ['cprogram', 'cshlib', 'cstlib', 'cxxprogram', 'cxxshlib', 'cxxstlib']:
			link_task(self)
	Task.TaskBase.process = process

	def output_makefile(self):
		targets = list(self.targets)
		if not len(targets):
			return

		bindir = str(self.env.BINDIR)
		libdir = str(self.env.LIBDIR)
		lines = []
		lines.append("all: \\")
		lines.append("\t%s" % ' \\\n\t'.join([t if t.endswith('.o') else os.path.basename(t) for t in targets]))

		lines.append("")
		lines.append("clean:")
		for tgt in self.targets:
			lines.append("\trm -rf  %s" % tgt)

		lines.append("")
		lines.append("install:")
		lines.append("\tmkdir -p %s" % bindir)
		lines.append("\tmkdir -p %s" % libdir)
		for tgt in [t for t in self.targets if not t.endswith('.a') and not t.endswith('.o')]:
			f = os.path.basename(str(tgt))
			if f.endswith('.so'):
				p = libdir
			else:
				p = bindir
			lines.append("\tcp %s  %s/%s" % (tgt,p,f))

		lines.append("")
		lines.append("uninstall:")
		for tgt in [t for t in self.targets if not t.endswith('.a') and not t.endswith('.o')]:
			f = os.path.basename(str(tgt))
			if f.endswith('.so'):
				p = libdir
			else:
				p = bindir
			lines.append("\trm -rf  %s/%s" % (p,f))

		for cmd in self.commands:
			if not cmd.startswith('\t'):
				lines.append("")
			lines.append(cmd)
		lines.append("\t\n")

		prefix = str(self.env.PREFIX)
		appname = getattr(Context.g_module, Context.APPNAME, os.path.basename(self.srcnode.abspath()))
		version = getattr(Context.g_module, Context.VERSION, os.path.basename(self.srcnode.abspath()))

		node = self.path.make_node('Makefile')
		header  = "# This makefile has been generated by waf.\n"
		header += "#\n"
		header += "# project : %s\n" % appname
		header += "# version : %s\n" % version
		header += "# waf     : %s\n" % Context.WAFVERSION
		header += "# time    : %s\n" % datetime.datetime.now()
		header += "#\n"
		header += "PREFIX=%s\n" % prefix
		header += "\n"
		content = "\n".join(lines)
		content = content.replace(prefix, "$(PREFIX)")
		node.write(header + content)
		Logs.warn('exported: %s' % node.abspath())

	bld.add_post_fun(output_makefile)
	


